# Настройка проекта STM32 в редакторе VSCode

*Пример проекта для МК STM32F103C8*

Используется:
- редактор кода Visual Studio Code
- STM32CubeMX
- ARM toolchain
- make (windows-build-tools)
- OpenOCD
- расширение vscode для отладки Cortex-Debug
- ST-LINK_CLI (St-Link Utility)

*Ролики на YouTube:*
- [первый](https://www.youtube.com/watch?v=PxQw5_7yI8Q)
- [второй](https://www.youtube.com/watch?v=xaC5oWwzOt0)

## Установка toolchain, make и OpenOCD
Скачиваем:
- ARM toolchain gcc-arm-none-eabi
- xpack-windows-build-tools (в составе есть утилита make)
- OpenOCD

Создаём папку на диске, распаковываем туда все эти инструемнты по разным папкам. Добавляем пути к папкам `/bin` в системную переменную `PATH`. В командной строке проверяем доступность всех программ. В VSCode находим и устанавливаем расширение Cortex-Debug (author marus25) для отладки. Также должно быть установлено расширение поддержки C/C++.

***ПРИМЕЧАНИЕ.***
В первом видеоролике автор скачивает только утилиту make, древней версии. Здесь решено использовать набор инструментов сборки windows-build-tools, в составе которого есть make, более новой версии, а также некоторые вспомогательные утилиты, типа rm.exe, которые использует Makefile.


## Создание проекта в STM32CubeMX
Создаём проект в CubeMX для конкретного МК. Конфигирируем проект в CubeMX, настраиваемый переферию.
В Project Manager в разделе Project указываем название проекта и директорию. Application Structure лучше выбрать Basic. Toolchain/IDE выбираем как Makefile. Так мы получим все необходимые файлы для сборки проекта - сам Makefile и linker script. В разделе Code Generator отмечаем второй пункт - "Copy only the necessary library files". Так в папку проекта скопируются только необходимые файлы.
Генерируем код, получаем следующую струкутуру папок:

- `Drivers/` - файлы драйвера HAL
- `Middlewares/` - файлы библиотек среднего уровня, напр. FreeRTOS, FatFs и др. (если подключены к проекту)
- `Inc/` - заголовочные файлы
- `Src/` - исходный код
- `****_FLASH.ld` - скрипт линковщика. 
- `Makefile` - набор инструкций для утилиты `make`
- `startup_***.s` - ассемблерный файл, код которого исполняется при старте процессора
- два файла программы CubeMX, их не трогаем если хотим отставить возможность обновлять код инициализации в CubeMX 

## Сборока проекта через командную строку и загрузка прошивки
Открываем командную строку, переходим в директорию проекта. Вызываем команду:
```
    make 
```
Mожно с ключом -j для параллельной сборки
```
    make -j
```
В папке проекта создатся папка `build/`, где будут находиться созданные компилятором объектные файлы `.o`, файл `.elf`, собранный линковщиком, бинарный `.bin` и HEX `.hex` файлы. Также ещё будут и другие фалы, полученный в процессе компиляции и линковки.

Для загрузки прошивки в МК, в Makefile необходимо добавить команды загрузки в память. Для загрузки используется ST-LINK_CLI - это консольная утилита от ST. Добавляем в Makefile новую цель - загрузка в МК через stlink, назовём, например, `fstlink`. 
Цель выглядит так:

```makefile
    fstlink: all
        st-link_cli -P $(BUILD_DIR)/$(TARGET).bin $(FADDR) -V after_programming -Rst
```

Перед вызовом цели `fstlink`, вызывается цель `all`, чтобы собрать проект. 
В `st-link_cli` передаём:
   - флаг `-P` (смотри документацию на ST-LINK Utility)
   - бинарный файл `$(BUILD_DIR)/$(TARGET).bin` (имя файла определно переменными в Makefile)
   - начальный адрес раположения прошивки `$(FADDR)` - эта переменную определяем в Makefile
```makefile
    ######################################
    # flashing variables
    ######################################
    # flash origin (начальный адес флеш, по умолчанию начало области 0x08000000)
    FADDR = 0x08000000
```
   - `-V after_programming` - произвести верификацию прошивки после загрузки
   - `-Rst` - сбросить МК (Software Reset)

Команду загрузки будет выглядеть так:
```
make fstlink
```

Адрес раположения прошивки можно указать: `make fstlink FADDR=0x08****`. Таким образом переменная FADDR переопределяется через командную строку. Например:
```
make fstlink FADDR=0x08000C00
```
*(пробелы возле равно не ставить!)*

Адрес должен быть тот же, что и скрипте линковщика.
Также можно использовать OpenOCD для загрузки прошивки, как это показано в 1-ом видеоролике. Добавляем в Makefile новую цель:
```makefile
    #######################################
    # flash by OpenOCD
    #######################################
    fopenocd: all
	    openocd -f interface/stlink.cfg -f target/stm32f1x.cfg -c "program $(BUILD_DIR)/$(TARGET).elf verify reset exit"
```



## Настройка VSCode
Настройка VSCode показана [во 2-ом видеоролике](https://www.youtube.com/watch?v=xaC5oWwzOt0). 
Добавляем папку проекта в рабочую область vscode. Теперь нужно настроить среду для разработки на C/C++. Для этого добавляем файл `c_cpp_properties.json`. Смысл этого файла - дать знать vscode пути к заголовочным файлам, укзаать на используемый компилятор, задать стандарты языка и т.д. Пример настройки можно найти в этом проекте. Этот и другие файлы настройки располагаются в папке `.vscode/`.
Добавляем ещё один файл `launch.json`. В нём задаются настройки для отладки. Пример фала также есть в этом проекте.
Вообщем, на данном этапе vscode позволяет редактировать код, с автодополнением и навигацией по коду. А сборку проекта и прошивку следует делать из командйной строки, используя `make`.

***ПРИМЕЧАНИЕ 1.*** С командной строкой можно рабоать из vscode, так как есть интегрированный терминал. Команды для задачи, прописанных в tasks.json (фалйл, где можно прописать сценарий сборки проекта, загрузки и другие действия и привзяать их к горячим клавишам) также исполняется из командной строки встроенного терминала. Но есть ПРОБЛЕМА СО ВСТРОЕННЫМ ТЕРМИНАЛОМ! Он не видит пути, прописанные в системном PATH. У него какой-то свой PATH, которой неизвестно как получился и как его настроить.

***ПРИМЕЧАНИЕ 2.*** В выходных файлах ARM toolchain в папке build есть интересный файл с расширением .map, который создаёт linker. В нём описана струкутра памяти, адреса программ, функций и много всего. Чтобы его просмтривать можно установить расширение GNU linker Map files. Также можно установить расширение LinkerScript для чтения файла скрипта линковщика *.ld (GNU linker script).
